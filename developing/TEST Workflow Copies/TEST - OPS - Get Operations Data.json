{
  "name": "TEST - OPS - Get Operations Data",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "TEST-get-operations-data",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "id": "webhook-ops-data",
      "name": "POST Get Operations Data - Webhook",
      "webhookId": "ops-get-data"
    },
    {
      "parameters": {
        "jsCode": "// JWT Token Validation - v1.0.0\n// Operations page requires admin/supervisor role\n\nconst webhookData = $input.first().json;\nconst authHeader = webhookData.headers?.authorization || webhookData.headers?.Authorization;\n\nif (!authHeader) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Missing authorization header',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nif (!authHeader.startsWith('Bearer ')) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Invalid authorization format',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst token = authHeader.substring(7);\n\nfunction simpleHash(input) {\n  let hash = 0;\n  for (let i = 0; i < input.length; i++) {\n    const char = input.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return hash.toString(36);\n}\n\nconst JWT_SECRET = \"***REMOVED***\";\n\nfunction verifyJWT(token) {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return { valid: false, error: 'Invalid token format' };\n    }\n\n    const [encodedHeader, encodedPayload, receivedSignature] = parts;\n    const dataToSign = `${encodedHeader}.${encodedPayload}.${JWT_SECRET}`;\n    const expectedSignature = simpleHash(dataToSign);\n\n    if (receivedSignature !== expectedSignature) {\n      return { valid: false, error: 'Invalid token signature' };\n    }\n\n    const payload = JSON.parse(atob(encodedPayload));\n    const now = Math.floor(Date.now() / 1000);\n    if (payload.exp && payload.exp < now) {\n      return { valid: false, error: 'Token expired' };\n    }\n\n    return { valid: true, payload: payload };\n\n  } catch (error) {\n    return { valid: false, error: 'Token verification failed' };\n  }\n}\n\nconst validation = verifyJWT(token);\n\nif (!validation.valid) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: validation.error || 'Invalid token',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst payload = validation.payload;\n\nif (payload.type === 'limited' || payload.type === 'refresh') {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'This operation requires full authentication',\n      statusCode: 403,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Role check - only admin and supervisor\nconst allowedRoles = ['admin', 'supervisor'];\nif (!allowedRoles.includes(payload.role)) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Access denied. Requires admin or supervisor role.',\n      statusCode: 403,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    _route: 'authorized',\n    authenticated: true,\n    user: {\n      id: payload.userId,\n      username: payload.sub,\n      role: payload.role,\n      fullName: payload.fullName\n    },\n    requestBody: webhookData.body,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300],
      "id": "jwt-validation",
      "name": "JWT Validation - Code"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "authorized",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Authorized"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "unauthorized",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Unauthorized"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [440, 300],
      "id": "jwt-switch",
      "name": "JWT Validation - Switch"
    },
    {
      "parameters": {
        "jsCode": "// Parse Week Parameters - v1.0.0\n// Calculate 2-week date range for Operations view\n\nconst authData = $input.first().json;\nconst body = authData.requestBody || {};\n\n// Get week start from request or calculate current week's Monday\nlet weekStart;\nif (body.weekStart) {\n  weekStart = new Date(body.weekStart + 'T00:00:00');\n} else {\n  const today = new Date();\n  const dayOfWeek = today.getDay();\n  const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n  weekStart = new Date(today);\n  weekStart.setDate(today.getDate() - daysToMonday);\n}\nweekStart.setHours(0, 0, 0, 0);\n\n// Calculate end of 2-week period (Friday of next week + buffer)\nconst weekEnd = new Date(weekStart);\nweekEnd.setDate(weekStart.getDate() + 13); // Full 2 weeks\nweekEnd.setHours(23, 59, 59, 999);\n\nconst weekStartStr = weekStart.toISOString().split('T')[0];\nconst weekEndStr = weekEnd.toISOString().split('T')[0];\n\nreturn [{\n  json: {\n    user: authData.user,\n    weekStart: weekStartStr,\n    weekEnd: weekEndStr,\n    weekStartISO: weekStart.toISOString(),\n    weekEndISO: weekEnd.toISOString(),\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 200],
      "id": "parse-week",
      "name": "Parse Week Parameters - Code"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "appointments",
        "returnAll": true,
        "filterType": "string",
        "filterString": "select=*&appointmenttime=gte.{{ $json.weekStartISO }}&appointmenttime=lte.{{ $json.weekEndISO }}"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 0],
      "id": "get-appointments",
      "name": "Get Appointments - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "your-credential-id",
          "name": "Supabase Testing"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "drivers",
        "returnAll": true,
        "filterType": "string",
        "filterString": "active=eq.true"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 200],
      "id": "get-drivers",
      "name": "Get Drivers - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "your-credential-id",
          "name": "Supabase Testing"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "destinations",
        "returnAll": true,
        "filterType": "string",
        "filterString": "active=eq.true"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 400],
      "id": "get-clinics",
      "name": "Get Clinics - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "your-credential-id",
          "name": "Supabase Testing"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "driver_clinic_assignments",
        "returnAll": true
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 600],
      "id": "get-driver-clinic",
      "name": "Get Driver Clinic Assignments - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "your-credential-id",
          "name": "Supabase Testing"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "operations_draft_assignments",
        "returnAll": true,
        "filterType": "string",
        "filterString": "week_start=gte.{{ $('Parse Week Parameters - Code').item.json.weekStart }}"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [900, 800],
      "id": "get-drafts",
      "name": "Get Draft Assignments - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "your-credential-id",
          "name": "Supabase Testing"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1140, 400],
      "id": "merge-all",
      "name": "Merge All - Merge"
    },
    {
      "parameters": {
        "jsCode": "// Combine Operations Data - v1.0.0\n// Separates merged data into categories\n\ntry {\n  const allItems = $input.all().map(item => item.json);\n  const weekParams = $('Parse Week Parameters - Code').first().json;\n  const user = weekParams.user;\n\n  // Separate items by distinctive fields\n  const appointments = allItems.filter(item =>\n    item.appointmenttime !== undefined && item.knumber !== undefined\n  );\n\n  // Drivers have name/first_name/last_name and google_calendar_id\n  const drivers = allItems.filter(item =>\n    (item.name !== undefined || item.first_name !== undefined) &&\n    item.google_calendar_id !== undefined &&\n    item.clinic_id === undefined\n  );\n\n  // Clinics/destinations have name and address\n  const clinics = allItems.filter(item =>\n    item.name !== undefined &&\n    item.address !== undefined &&\n    item.google_calendar_id === undefined\n  );\n\n  // Driver-clinic assignments have driver_id, clinic_id, is_primary\n  const driverClinicAssignments = allItems.filter(item =>\n    item.driver_id !== undefined &&\n    item.clinic_id !== undefined &&\n    item.is_primary !== undefined\n  );\n\n  // Draft assignments have appointment_id and week_start\n  const draftAssignments = allItems.filter(item =>\n    item.appointment_id !== undefined &&\n    item.week_start !== undefined\n  );\n\n  // Format appointments for frontend\n  const formattedAppointments = appointments.map(apt => {\n    const aptTime = new Date(apt.appointmenttime);\n    return {\n      id: apt.id,\n      knumber: apt.knumber,\n      appointmentDate: aptTime.toISOString().split('T')[0],\n      appointmentTime: aptTime.toTimeString().slice(0, 5),\n      appointmentDateTime: apt.appointmenttime,\n      appointmentLength: apt.this_appointment_length || 120,\n      transitTime: apt.transittime || 30,\n      location: apt.locationname,\n      locationAddress: apt.locationaddress,\n      clinic_id: apt.clinic_id,\n      pickup_address: apt.pickup_address,\n      driver_assigned: apt.driver_assigned,\n      driver_name: apt.driver_first_name,\n      status: apt.appointmentstatus || 'scheduled',\n      notes: apt.notes,\n      driver_instructions: apt.driver_instructions,\n      scheduling_notes: apt.scheduling_notes,\n      google_calendar_event_id: apt.driver_calendar_event_id\n    };\n  });\n\n  // Format drivers\n  const formattedDrivers = drivers.map(d => ({\n    id: d.id,\n    name: d.name || `${d.first_name || ''} ${d.last_name || ''}`.trim(),\n    phone: d.phone,\n    email: d.email,\n    google_calendar_id: d.google_calendar_id\n  }));\n\n  // Format clinics\n  const formattedClinics = clinics.map(c => ({\n    id: c.id,\n    name: c.name,\n    address: c.address\n  }));\n\n  // Find last draft update\n  let lastDraftUpdate = null;\n  if (draftAssignments.length > 0) {\n    const sorted = draftAssignments.sort((a, b) =>\n      new Date(b.last_edited_at) - new Date(a.last_edited_at)\n    );\n    const latest = sorted[0];\n    lastDraftUpdate = {\n      editedBy: latest.last_edited_by_name,\n      editedAt: latest.last_edited_at\n    };\n  }\n\n  return [{\n    json: {\n      success: true,\n      data: {\n        appointments: formattedAppointments,\n        drivers: formattedDrivers,\n        clinics: formattedClinics,\n        driverClinicAssignments: driverClinicAssignments,\n        draftAssignments: draftAssignments,\n        metadata: {\n          weekStart: weekParams.weekStart,\n          weekEnd: weekParams.weekEnd,\n          lastDraftUpdate: lastDraftUpdate,\n          requestedBy: user.fullName\n        }\n      },\n      counts: {\n        appointments: formattedAppointments.length,\n        drivers: formattedDrivers.length,\n        clinics: formattedClinics.length,\n        driverClinicAssignments: driverClinicAssignments.length,\n        draftAssignments: draftAssignments.length\n      },\n      message: 'Operations data loaded successfully',\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (error) {\n  return [{\n    json: {\n      success: false,\n      message: 'Failed to load operations data',\n      error: error.message,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 400],
      "id": "combine-data",
      "name": "Combine Operations Data - Code"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1580, 400],
      "id": "respond-success",
      "name": "Success Response - Respond"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": "={{ $json.statusCode || 401 }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [660, 500],
      "id": "respond-error",
      "name": "Error Response - Respond"
    }
  ],
  "connections": {
    "POST Get Operations Data - Webhook": {
      "main": [
        [
          {
            "node": "JWT Validation - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JWT Validation - Code": {
      "main": [
        [
          {
            "node": "JWT Validation - Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JWT Validation - Switch": {
      "main": [
        [
          {
            "node": "Parse Week Parameters - Code",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response - Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Week Parameters - Code": {
      "main": [
        [
          {
            "node": "Get Appointments - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Drivers - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Clinics - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Driver Clinic Assignments - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Draft Assignments - Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Appointments - Supabase": {
      "main": [
        [
          {
            "node": "Merge All - Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Drivers - Supabase": {
      "main": [
        [
          {
            "node": "Merge All - Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Clinics - Supabase": {
      "main": [
        [
          {
            "node": "Merge All - Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Get Driver Clinic Assignments - Supabase": {
      "main": [
        [
          {
            "node": "Merge All - Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Get Draft Assignments - Supabase": {
      "main": [
        [
          {
            "node": "Merge All - Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge All - Merge": {
      "main": [
        [
          {
            "node": "Combine Operations Data - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Operations Data - Code": {
      "main": [
        [
          {
            "node": "Success Response - Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-17T00:00:00.000Z",
  "versionId": "1"
}
