{
  "name": "TEST - APPT - Get ALL Appointments (Historic Data) copy",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.3,
      "position": [
        1440,
        656
      ],
      "id": "b50dee7c-0cf8-4d02-8c47-ee65bdb9c0f9",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "path": "TEST-get-historic-appointments",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -768,
        352
      ],
      "id": "f8777ddf-a475-4284-a079-f38266b2ff3a",
      "name": "Appointments List Request - Webhook",
      "webhookId": "c4eb53bf-0695-48b4-812c-bb6a0d0d1b7a"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "clients",
        "returnAll": true
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        208,
        0
      ],
      "id": "8d1cd534-c643-4df2-b0e5-13e2bed8c25c",
      "name": "Get Clients - Supabase",
      "executeOnce": false,
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Simple Appointments Processing - v2.4.0\n// Processes enriched appointment records from merge node\n\n\ntry {\n    // Get all appointment records from merge node\n    const appointments = $input.all().map(item => item.json);\n\n    \n    if (appointments.length === 0) {\n        return [{\n            json: {\n                success: true,\n                appointments: [],\n                totalAppointments: 0,\n                message: 'No appointments found'\n            }\n        }];\n    }\n    \n    // Process each appointment record\n    const processedAppointments = appointments.map(apt => {\n        // Extract date and time from appointmenttime\n        const appointmentDate = new Date(apt.appointmenttime);\n        const dateStr = appointmentDate.toISOString().split('T')[0]; // YYYY-MM-DD\n        const timeStr = appointmentDate.toTimeString().slice(0, 5); // HH:MM\n        \n        return {\n            id: apt.id,\n            appointmentDate: dateStr,\n            appointmentTime: timeStr,\n            appointmentDateTime: apt.appointmenttime,\n            pickupTime: apt.pickuptime,\n            dropOffTime: apt.dropOffTime,  // ✅ ADD THIS FIELD\n            location: apt.locationname,\n            locationAddress: apt.locationaddress,\n            notes: apt.scheduling_notes || apt.notes || '',  // ✅ UPDATED: Prioritize scheduling_notes\n            scheduling_notes: apt.scheduling_notes || '',  // ✅ NEW: Include scheduling_notes field\n            status: apt.appointmentstatus,\n            transitTime: apt.transittime,\n            customRate: apt.custom_rate,\n            appointmentLength: apt.this_appointment_length,\n            driverAssigned: apt.driver_assigned,\n            driverCalendarEventId: apt.driver_calendar_event_id,\n            clientNotificationSent: apt.client_notification_sent || false,\n            driverNotificationSent: apt.driver_notification_sent || false,\n            reminderSentClient: apt.reminder_sent_client || false,\n            reminderSentDriver: apt.reminder_sent_driver || false,\n            knumber: apt.knumber,\n            clientName: apt.firstname && apt.lastname ? `${apt.firstname} ${apt.lastname}` : 'Unknown Client',\n            clientFirstName: apt.firstname || '',\n            clientLastName: apt.lastname || '',\n            clientPhone: apt.phone || '',\n            clientEmail: apt.email || '',\n            clientAddress: apt.civicaddress || '',\n            clientCity: apt.city || '',\n            clientProvince: apt.prov || '',\n            clientPostalCode: apt.postalcode || '',\n            createdAt: apt.created_at\n        };\n    });\n    \n    // Sort by appointment date/time\n    processedAppointments.sort((a, b) => new Date(a.appointmentDateTime) - new Date(b.appointmentDateTime));\n    \n\n    \n    return [{\n        json: {\n            success: true,\n            appointments: processedAppointments,\n            totalAppointments: processedAppointments.length,\n            clientsProcessed: processedAppointments.length,\n            message: `Successfully processed ${processedAppointments.length} appointments with client data`\n        }\n    }];\n    \n} catch (error) {\n    console.error('Error processing appointments:', error);\n    return [{\n        json: {\n            success: false,\n            error: \"Processing error\",\n            message: error.message,\n            appointments: [],\n            totalAppointments: 0\n        }\n    }];\n}\n\n// Version: v2.4.0 - Added scheduling_notes field support\n// - v2.4.0: Added scheduling_notes field to returned data (prioritizes scheduling_notes over notes)\n// - v2.3.0: Added driverCalendarEventId field for calendar event tracking\n// - v2.1.0: Added driver assignment and notification status fields\n// - v2.0.0: Added this_appointment_length field to processed appointments\n// - v1.9.0: Enhanced Merge Node Data Processing\n// - v1.8.0: Back to flat array handling - \"Combine\" mode still creates mixed array structure\n// - v1.7.0: Updated for merge node \"Combine\" mode - clean input separation\n// - v1.6.0: Fixed to handle merge node's flat array structure (appointments and clients mixed together)"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        832,
        96
      ],
      "id": "c2433fc0-6422-4d88-9678-84df958a26b6",
      "name": "Combine Appointments and Clients - Code"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "knumber",
        "joinMode": "enrichInput2",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        624,
        96
      ],
      "id": "aa438aa3-542d-44e2-9557-5a1ee07116e6",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "appointments",
        "returnAll": true,
        "filterType": "none"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        208,
        176
      ],
      "id": "441784af-287e-46e5-83f3-f98fdaa264a8",
      "name": "Get Appointments - Supabase",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Rename Client ID Field to Prevent Merge Conflicts - v1.0.0\n// Renames 'id' to 'clientId' to avoid overwriting appointment IDs during merge\n\n\ntry {\n    const clients = $input.all().map(item => {\n        const client = item.json;\n        \n        // Rename the id field to clientId to prevent merge conflicts\n        return {\n            clientId: client.id,  // Rename id to clientId\n            knumber: client.knumber,\n            firstname: client.firstname,\n            lastname: client.lastname,\n            phone: client.phone,\n            email: client.email,\n            civicaddress: client.civicaddress,\n            city: client.city,\n            prov: client.prov,\n            postalcode: client.postalcode,\n            emergency_contact_name: client.emergency_contact_name,\n            emergency_contact_number: client.emergency_contact_number,\n            notes: client.notes,\n            created_at: client.created_at\n        };\n    });\n    \n\n    \n    return clients.map(client => ({ json: client }));\n    \n} catch (error) {\n    console.error('Error renaming client ID fields:', error);\n    return [{\n        json: {\n            error: 'Failed to process client data',\n            message: error.message\n        }\n    }];\n}\n\n// Version: v1.0.0 - Client ID Field Renaming\n// - Prevents merge node from overwriting appointment IDs with client IDs\n// - Renames client 'id' field to 'clientId' to avoid field name conflicts\n// - Maintains all other client data structure\n// - Enables clean merge of appointment and client data by knumber"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        0
      ],
      "id": "838a1b77-736c-499c-aa2c-bada2cab7df1",
      "name": "Change id to clientID - Code"
    },
    {
      "parameters": {
        "jsCode": "// JWT Token Validation for Backend Workflows\n// Version: v1.0.0\n// Use this code node at the start of any protected workflow\n\n// Get webhook input data\nconst webhookData = $input.first().json;\n\n// Extract Authorization header\nconst authHeader = webhookData.headers?.authorization || webhookData.headers?.Authorization;\n\nif (!authHeader) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Missing authorization header',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Check Bearer token format\nif (!authHeader.startsWith('Bearer ')) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Invalid authorization format. Expected \"Bearer {token}\"',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Extract token\nconst token = authHeader.substring(7); // Remove \"Bearer \" prefix\n\n// JWT validation functions (matching generation code)\nfunction simpleHash(input) {\n  let hash = 0;\n  for (let i = 0; i < input.length; i++) {\n    const char = input.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return hash.toString(36);\n}\n\nconst JWT_SECRET = \"***REMOVED***\";\n\nfunction verifyJWT(token) {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return { valid: false, error: 'Invalid token format' };\n    }\n\n    const [encodedHeader, encodedPayload, receivedSignature] = parts;\n\n    // Verify signature\n    const dataToSign = `${encodedHeader}.${encodedPayload}.${JWT_SECRET}`;\n    const expectedSignature = simpleHash(dataToSign);\n\n    if (receivedSignature !== expectedSignature) {\n      return { valid: false, error: 'Invalid token signature' };\n    }\n\n    // Decode payload\n    const payload = JSON.parse(atob(encodedPayload));\n\n    // Check expiration\n    const now = Math.floor(Date.now() / 1000);\n    if (payload.exp && payload.exp < now) {\n      return { valid: false, error: 'Token expired' };\n    }\n\n    return { valid: true, payload: payload };\n\n  } catch (error) {\n    return { valid: false, error: 'Token verification failed: ' + error.message };\n  }\n}\n\n// Validate the token\nconst validation = verifyJWT(token);\n\nif (!validation.valid) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: validation.error || 'Invalid token',\n      statusCode: 401,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst payload = validation.payload;\n\n// Check token type (reject LIMITED tokens unless specifically allowed)\n// Note: Individual workflows can override this by setting allowLimitedToken in webhook body\nconst allowLimitedToken = webhookData.body?.allowLimitedToken || false;\n\nif (payload.type === 'limited' && !allowLimitedToken) {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'This operation requires full authentication. Please complete password change.',\n      statusCode: 403,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Check if refresh token is being used for non-refresh operations\nif (payload.type === 'refresh') {\n  return [{\n    json: {\n      _route: 'unauthorized',\n      success: false,\n      message: 'Refresh tokens cannot be used for this operation',\n      statusCode: 403,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Token is valid - return user info and original request body\nreturn [{\n  json: {\n    _route: 'authorized',\n    authenticated: true,\n    user: {\n      username: payload.sub,\n      role: payload.role,\n      tokenType: payload.type,\n      permissions: payload.permissions || []\n    },\n    requestBody: webhookData.body,\n    timestamp: new Date().toISOString()\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -544,
        352
      ],
      "id": "8b95abda-6905-490c-bcc6-95b27d1b5f6c",
      "name": "JWT Validation - Code"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "authorized",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "aeef0039-074f-48b0-b9f4-452772fabdf4"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Authorized"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "30766672-03aa-41da-85e5-b12bbbc6972c",
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "unauthorized",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Unauthorized"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -336,
        352
      ],
      "id": "fe06beb6-d23c-4633-864c-d49a8262502d",
      "name": "JWT Validation - Switch"
    },
    {
      "parameters": {
        "jsCode": "  // Format Unauthorized Error Response - Simple Version\n  // Version: v1.0.0\n\n  const errorData = $input.first().json;\n\n  // Return standardized error format\n  return [{\n    json: {\n      success: false,\n      error: {\n        message: errorData.message || 'Unauthorized access',\n        statusCode: errorData.statusCode || 401\n      },\n      timestamp: errorData.timestamp || new Date().toISOString()\n    }\n  }]"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        464
      ],
      "id": "0bcc73ea-f468-4080-a2dd-4f3dc095afe9",
      "name": "Unauthorized Response - Code"
    }
  ],
  "pinData": {},
  "connections": {
    "Appointments List Request - Webhook": {
      "main": [
        [
          {
            "node": "JWT Validation - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Clients - Supabase": {
      "main": [
        [
          {
            "node": "Change id to clientID - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Appointments and Clients - Code": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Combine Appointments and Clients - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Appointments - Supabase": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Change id to clientID - Code": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JWT Validation - Code": {
      "main": [
        [
          {
            "node": "JWT Validation - Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JWT Validation - Switch": {
      "main": [
        [
          {
            "node": "Get Appointments - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Clients - Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unauthorized Response - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unauthorized Response - Code": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "bbc73758-ce3f-46c9-8de6-697a97da4da2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "62fe1973b06b53c2a918f891d003328ecd43cc9389e3ac0f24384782e956f6ca"
  },
  "id": "boGEtHBXd4B70EeV",
  "tags": [
    {
      "updatedAt": "2025-10-30T17:13:53.320Z",
      "createdAt": "2025-10-30T17:13:53.320Z",
      "id": "3od10wQiA1OAAozv",
      "name": "Appointment Management"
    },
    {
      "updatedAt": "2025-10-30T17:14:14.689Z",
      "createdAt": "2025-10-30T17:14:14.689Z",
      "id": "UVqUsgcbAWMJohPQ",
      "name": "Driver Management"
    },
    {
      "updatedAt": "2025-11-02T20:39:22.246Z",
      "createdAt": "2025-11-02T20:39:22.246Z",
      "id": "Gm2wdYiA4AnCKH8r",
      "name": "with JWT"
    },
    {
      "updatedAt": "2025-11-09T06:15:47.425Z",
      "createdAt": "2025-11-09T06:15:47.425Z",
      "id": "tZpzEwpoeg8SrGGa",
      "name": "TEST"
    }
  ]
}