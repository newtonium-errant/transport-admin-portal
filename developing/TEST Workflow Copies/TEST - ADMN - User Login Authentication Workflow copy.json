{
  "name": "TEST - ADMN - User Login Authentication Workflow copy",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "TEST-user-login",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "fabfca5c-a5e1-4ad3-b809-69eff6b4b7bd",
      "name": "User Login - Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -960,
        464
      ],
      "webhookId": "8fd48941-2cb3-4cb8-8f4b-5167de96f8d3"
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "username",
              "keyValue": "={{ $json.body.username }}"
            }
          ]
        }
      },
      "id": "0e5bfc28-a89b-431c-8aa7-b33dd21a293b",
      "name": "Lookup User - Supabase",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -768,
        464
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {
        "tableId": "user_sessions",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "username",
              "fieldValue": "={{ $json.username }}"
            },
            {
              "fieldId": "session_token",
              "fieldValue": "={{ $json.createSession.sessionToken }}"
            },
            {
              "fieldId": "expires_at",
              "fieldValue": "={{ $json.createSession.expiresAt }}"
            }
          ]
        }
      },
      "id": "321e0387-5e91-487d-800e-676b05826e5a",
      "name": "Create Session - Supabase",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        192
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "username",
              "condition": "eq",
              "keyValue": "={{ $json.username }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "failed_login_attempts",
              "fieldValue": "={{ $json.updateUser.failed_login_attempts }}"
            },
            {
              "fieldId": "locked_until",
              "fieldValue": "={{ $json.updateUser.locked_until }}"
            }
          ]
        }
      },
      "id": "c50b7ca4-df4d-4e4b-be07-f8e20cef3804",
      "name": "Update Failed Login - Supabase",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        400
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {},
      "id": "fde9e613-be10-42d5-966b-a2897bb108aa",
      "name": "Merge Success - Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        240,
        96
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "ebe8e854-368a-4269-a459-c116d37675c9",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        944,
        464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Authentication with JWT for RRTS 4\n// Version: RRTS-4-AUTH-JWT-v3.1.0\n// - v3.1.0: Added userId to JWT responses for audit logging\n// - v3.0.0: Added JWT generation with must_change_password support\n// - v2.3.0: Fixed webhook body access\n// - v2.0.0: Added database lookup\n\n// ===== JWT UTILITY FUNCTIONS =====\n\n// Simple hash function (TEMPORARY - Phase 6 will use proper crypto)\nfunction simpleHash(input) {\n  let hash = 0;\n  for (let i = 0; i < input.length; i++) {\n    const char = input.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return hash.toString(36);\n}\n\n// JWT Secret (TODO: Move to environment variable)\nconst JWT_SECRET = \"REPLACE_WITH_ENV_VAR_JWT_SECRET\";\n\n// Generate JWT\nfunction generateJWT(payload) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n\n  // Base64 encode header and payload\n  const encodedHeader = btoa(JSON.stringify(header));\n  const encodedPayload = btoa(JSON.stringify(payload));\n\n  // Create signature\n  const dataToSign = `${encodedHeader}.${encodedPayload}.${JWT_SECRET}`;\n  const signature = simpleHash(dataToSign);\n\n  // Return complete JWT\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}\n\n// ===== PASSWORD VERIFICATION =====\n\n// Verify hashed password\nfunction verifyPassword(password, storedHash) {\n  if (!storedHash.includes(':')) {\n    return password === storedHash;\n  }\n\n  const parts = storedHash.split(':');\n  if (parts.length !== 2) return false;\n\n  const salt = parts[0];\n  const storedHashValue = parts[1];\n  const computedHash = simpleHash(password + salt);\n\n  return computedHash === storedHashValue;\n}\n\n// ===== MAIN AUTHENTICATION LOGIC =====\n\n// Get webhook data\nconst webhookInput = $('User Login - Webhook').first().json;\nconst username = webhookInput.body.username?.trim();\nconst password = webhookInput.body.password;\nconst headers = webhookInput.headers || {};\nconst ipAddress = webhookInput.body.ipAddress || headers['x-forwarded-for'] || 'unknown';\nconst userAgent = webhookInput.body.userAgent || headers['user-agent'] || 'unknown';\n\n// Validation\nif (!username || !password) {\n  return [{\n    json: {\n      _route: 'error',\n      success: false,\n      message: 'Username and password are required',\n      loginTime: new Date().toISOString()\n    }\n  }];\n}\n\n// Get user data from Supabase\nconst lookupResult = $('Lookup User - Supabase').first().json;\n\nif (!lookupResult || !lookupResult.username) {\n  return [{\n    json: {\n      _route: 'failure',\n      success: false,\n      message: 'Invalid username or password',\n      username: username,\n      loginTime: new Date().toISOString(),\n      updateUser: null\n    }\n  }];\n}\n\nif (!lookupResult.is_active) {\n  return [{\n    json: {\n      _route: 'failure',\n      success: false,\n      message: 'Account is disabled. Contact administrator.',\n      username: username,\n      loginTime: new Date().toISOString(),\n      updateUser: null\n    }\n  }];\n}\n\n// Check for account lockout\nconst currentTime = new Date();\nconst lockedUntil = lookupResult.locked_until ? new Date(lookupResult.locked_until) : null;\n\nif (lockedUntil && currentTime < lockedUntil) {\n  const lockTimeRemaining = Math.ceil((lockedUntil - currentTime) / (1000 * 60));\n  return [{\n    json: {\n      _route: 'error',\n      success: false,\n      message: `Account is locked. Try again in ${lockTimeRemaining} minutes.`,\n      username: username,\n      loginTime: new Date().toISOString(),\n      lockedUntil: lookupResult.locked_until,\n      failedAttempts: lookupResult.failed_login_attempts || 0\n    }\n  }];\n}\n\n// Validate password\nconst isValidPassword = verifyPassword(password, lookupResult.password_hash);\n\nif (!isValidPassword) {\n  const failedAttempts = (lookupResult.failed_login_attempts || 0) + 1;\n  const maxAttempts = 5;\n  const lockoutDuration = 30;\n\n  let lockedUntilTime = null;\n  if (failedAttempts >= maxAttempts) {\n    lockedUntilTime = new Date(Date.now() + (lockoutDuration * 60 * 1000)).toISOString();\n  }\n\n  return [{\n    json: {\n      _route: 'failure',\n      success: false,\n      message: `Invalid username or password. ${maxAttempts - failedAttempts} attempts remaining.`,\n      username: username,\n      loginTime: new Date().toISOString(),\n      updateUser: {\n        failed_login_attempts: failedAttempts,\n        locked_until: lockedUntilTime\n      }\n    }\n  }];\n}\n\n// ===== PASSWORD VERIFIED - CHECK IF PASSWORD CHANGE REQUIRED =====\n\nconst mustChangePassword = lookupResult.must_change_password || false;\nconst now = Math.floor(Date.now() / 1000);\n\nif (mustChangePassword) {\n  // Generate LIMITED JWT (15 minutes, change-password only)\n  const limitedPayload = {\n    sub: username,\n    type: \"limited\",\n    permissions: [\"change_password\"],\n    iat: now,\n    exp: now + (15 * 60), // 15 minutes\n    jti: `limited_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  };\n\n  const limitedToken = generateJWT(limitedPayload);\n\n  return [{\n    json: {\n      _route: 'success',\n      success: true,\n      message: 'Login successful. Password change required.',\n      must_change_password: true,\n      limited_token: limitedToken,\n      token_type: 'limited',\n      expires_in: 900, // 15 minutes\n      userId: lookupResult.id,  // ‚Üê ADDED for audit logging\n      username: username,\n      userRole: lookupResult.role,\n      fullName: lookupResult.full_name,\n      email: lookupResult.email,\n      loginTime: new Date().toISOString(),\n      createSession: {\n        sessionToken: `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        expiresAt: new Date(Date.now() + (15 * 60 * 1000)).toISOString(),\n        ipAddress: ipAddress,\n        userAgent: userAgent\n      }\n    }\n  }];\n}\n\n// ===== NORMAL LOGIN - GENERATE FULL JWT + REFRESH TOKEN =====\n\n// Generate FULL JWT (1 hour)\nconst fullPayload = {\n  sub: username,\n  type: \"full\",\n  role: lookupResult.role,\n  permissions: [\"all\"],\n  iat: now,\n  exp: now + (60 * 60), // 1 hour\n  jti: `full_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n};\n\nconst accessToken = generateJWT(fullPayload);\n\n// Generate REFRESH TOKEN (7 days)\nconst refreshPayload = {\n  sub: username,\n  type: \"refresh\",\n  permissions: [\"refresh_access\"],\n  iat: now,\n  exp: now + (7 * 24 * 60 * 60), // 7 days\n  jti: `refresh_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n};\n\nconst refreshToken = generateJWT(refreshPayload);\n\nreturn [{\n  json: {\n    _route: 'success',\n    success: true,\n    message: 'Login successful',\n    must_change_password: false,\n    access_token: accessToken,\n    refresh_token: refreshToken,\n    token_type: 'Bearer',\n    expires_in: 3600, // 1 hour\n    userId: lookupResult.id,  // ‚Üê ADDED for audit logging\n    username: username,\n    userRole: lookupResult.role,\n    fullName: lookupResult.full_name,\n    email: lookupResult.email,\n    loginTime: new Date().toISOString(),\n    createSession: {\n      sessionToken: `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      expiresAt: new Date(Date.now() + (60 * 60 * 1000)).toISOString(),\n      ipAddress: ipAddress,\n      userAgent: userAgent\n    }\n  }\n}];\n"
      },
      "id": "e3022a4d-3887-4fc3-90a2-ce8ea7defb05",
      "name": "Authentication & Routing - Code",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        464
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "success",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "53684465-625f-460e-bd20-c5d705c01e82"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2d9dfa54-a289-4ee5-96dc-0a251c308675",
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "failure",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7b7c54a5-3837-490e-9eab-3bcce1f7b9b1",
                    "leftValue": "={{ $json._route }}",
                    "rightValue": "error",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -368,
        448
      ],
      "id": "14534bfc-a450-4cbc-b54c-afaf7abefc3a",
      "name": "Switch"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "username",
              "condition": "eq",
              "keyValue": "={{ $json.username }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "last_login",
              "fieldValue": "={{ $json.loginTime }}"
            },
            {
              "fieldId": "failed_login_attempts",
              "fieldValue": "0"
            }
          ]
        }
      },
      "id": "f86f6760-a8fa-4ce4-8347-484b79d223c2",
      "name": "Update User Success - Supabase",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pHAY0PSxRTkwJnPE",
          "name": "Testing Branch - Supabase"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        448,
        448
      ],
      "id": "ab46da05-82dd-4276-acb9-ea79071529e8",
      "name": "Final Merge - Merge",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Format Authentication Response for RRTS 4 - JWT + Session Handler\n// Version: RRTS-4-AUTH-RESPONSE-v3.1.0\n// Handles both JWT authentication and legacy session-based responses\n\n// FIRST: Check if Authentication & Routing returned JWT tokens\nconst authNode = $('Authentication & Routing - Code').first();\nif (authNode && authNode.json) {\n  const authData = authNode.json;\n\n  // If we have JWT tokens in the auth response, use that directly\n  if (authData.limited_token || authData.access_token) {\n    console.log('üîê JWT Authentication Response (from Auth node)');\n\n    // Return the JWT response unchanged\n    return [{\n      json: authData\n    }];\n  }\n}\n\n// Legacy session-based authentication (backwards compatibility)\nconst allInputs = $input.all();\nconsole.log('üì• Received inputs:', allInputs.length, 'items');\n\nconst sessionItem = allInputs.find(item => item.json.session_token);\nconst userItem = allInputs.find(item => item.json.username && !item.json.session_token);\n\nconsole.log('üîç Analysis:', {\n  hasSession: !!sessionItem,\n  hasUserUpdate: !!userItem,\n  sessionToken: sessionItem?.json.session_token?.substring(0, 20) + '...' || 'none',\n  failedAttempts: userItem?.json.failed_login_attempts || 0,\n  lockedUntil: userItem?.json.locked_until || null\n});\n\n// Check for account lockout first (from database results)\nif (userItem?.json.locked_until) {\n  const lockUntilTime = new Date(userItem.json.locked_until);\n  const currentTime = new Date();\n\n  if (currentTime < lockUntilTime) {\n    const lockTimeRemaining = Math.ceil((lockUntilTime - currentTime) / (1000 * 60));\n    console.log('üîí LOCKED: Account is locked');\n\n    return [{\n      json: {\n        success: false,\n        message: `Account is locked due to too many failed attempts. Try again in ${lockTimeRemaining} minutes.`,\n        lockedUntil: userItem.json.locked_until,\n        failedAttempts: userItem.json.failed_login_attempts,\n        canRetry: false,\n        loginTime: new Date().toISOString()\n      }\n    }];\n  }\n}\n\n// Check for failed login attempts (but not locked)\nif (userItem?.json.failed_login_attempts > 0 && !sessionItem) {\n  const maxAttempts = 5;\n  const attemptsRemaining = maxAttempts - userItem.json.failed_login_attempts;\n  console.log('‚ùå FAILURE: Login failed, attempts remaining:', attemptsRemaining);\n\n  return [{\n    json: {\n      success: false,\n      message: attemptsRemaining > 0\n        ? `Invalid username or password. ${attemptsRemaining} attempts remaining.`\n        : 'Invalid username or password.',\n      failedAttempts: userItem.json.failed_login_attempts,\n      lockedUntil: null,\n      canRetry: attemptsRemaining > 0,\n      loginTime: new Date().toISOString()\n    }\n  }];\n}\n\nif (sessionItem && userItem) {\n  // SUCCESS: Legacy session-based authentication\n  console.log('‚úÖ SUCCESS: Session authentication completed');\n\n  return [{\n    json: {\n      success: true,\n      message: 'Login successful',\n      username: sessionItem.json.username,\n      sessionToken: sessionItem.json.session_token,\n      expiresAt: sessionItem.json.expires_at,\n      role: userItem.json.role || 'admin',\n      fullName: userItem.json.full_name || '',\n      email: userItem.json.email || '',\n      loginTime: userItem.json.last_login || new Date().toISOString(),\n      redirect: '/dashboard'\n    }\n  }];\n\n} else if (allInputs.length === 1 && allInputs[0].json._route) {\n  // Handle direct routing from Authentication & Routing (failure/error cases)\n  const inputData = allInputs[0].json;\n\n  switch (inputData._route) {\n    case 'failure':\n      console.log('‚ùå FAILURE: Authentication failed');\n      return [{\n        json: {\n          success: false,\n          message: inputData.message || 'Invalid username or password',\n          failedAttempts: inputData.updateUser?.failed_login_attempts || 0,\n          lockedUntil: inputData.updateUser?.locked_until || null,\n          canRetry: !inputData.updateUser?.locked_until,\n          loginTime: inputData.loginTime\n        }\n      }];\n\n    case 'error':\n      console.log('üí• ERROR: System error during authentication');\n      return [{\n        json: {\n          success: false,\n          message: inputData.message || 'System error occurred during login',\n          error: 'SYSTEM_ERROR',\n          canRetry: true,\n          loginTime: inputData.loginTime || new Date().toISOString()\n        }\n      }];\n  }\n}\n\n// FALLBACK: Unexpected data format\nconsole.log('‚ö†Ô∏è UNEXPECTED: Unrecognized data format');\nconsole.log('Debug info:', {\n  inputCount: allInputs.length,\n  firstItem: allInputs[0]?.json,\n  hasRoute: !!allInputs[0]?.json?._route\n});\n\n  return [{\n    json: {\n      _route: 'success',\n      success: true,\n      message: 'Login successful',\n      must_change_password: false,\n      access_token: accessToken,\n      refresh_token: refreshToken,\n      token_type: 'Bearer',\n      expires_in: 3600,\n      userId: user.id,  // <-- ADD THIS LINE\n      username: user.username,\n      userRole: user.role,\n      fullName: user.full_name,\n      email: user.email,\n      loginTime: new Date().toISOString(),\n      createSession: sessionData\n    }\n  }];"
      },
      "id": "5763dd4a-9277-4b7f-ab39-ededb7948a43",
      "name": "Format Authentication Response - Code",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        464
      ]
    }
  ],
  "pinData": {
    "User Login - Webhook": [
      {
        "json": {
          "headers": {
            "host": "webhook-processor-production-3bb8.up.railway.app",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
            "content-length": "64",
            "accept": "*/*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "accept-language": "en-US,en;q=0.9",
            "content-type": "application/json",
            "origin": "null",
            "priority": "u=1, i",
            "sec-ch-ua": "\"Google Chrome\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "cross-site",
            "x-forwarded-for": "134.41.174.19",
            "x-forwarded-host": "webhook-processor-production-3bb8.up.railway.app",
            "x-forwarded-proto": "https",
            "x-railway-edge": "railway/us-east4-eqdc4a",
            "x-railway-request-id": "tmlB5I9FTQaqlmFRBT7zVQ",
            "x-real-ip": "134.41.174.19",
            "x-request-start": "1762279098434"
          },
          "params": {},
          "query": {},
          "body": {
            "username": "***REMOVED***",
            "password": "R@geRag3!."
          },
          "webhookUrl": "https://webhook-processor-production-3bb8.up.railway.app/webhook/user-login",
          "executionMode": "production"
        }
      }
    ]
  },
  "connections": {
    "User Login - Webhook": {
      "main": [
        [
          {
            "node": "Lookup User - Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup User - Supabase": {
      "main": [
        [
          {
            "node": "Authentication & Routing - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Session - Supabase": {
      "main": [
        [
          {
            "node": "Merge Success - Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Update Failed Login - Supabase": {
      "main": [
        [
          {
            "node": "Final Merge - Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Success - Merge": {
      "main": [
        [
          {
            "node": "Final Merge - Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Authentication & Routing - Code": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Update User Success - Supabase",
            "type": "main",
            "index": 0
          },
          {
            "node": "Create Session - Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Failed Login - Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Final Merge - Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Update User Success - Supabase": {
      "main": [
        [
          {
            "node": "Merge Success - Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Merge - Merge": {
      "main": [
        [
          {
            "node": "Format Authentication Response - Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Authentication Response - Code": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "2d9b2687-9aa9-43ec-a41e-2994654a3749",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "62fe1973b06b53c2a918f891d003328ecd43cc9389e3ac0f24384782e956f6ca"
  },
  "id": "r5btDrfGnMZzXGHl",
  "tags": [
    {
      "updatedAt": "2025-11-02T20:33:29.538Z",
      "createdAt": "2025-11-02T20:33:29.538Z",
      "id": "GH1TWRkaKLzUvb4Q",
      "name": "no JWT"
    },
    {
      "updatedAt": "2025-11-09T06:15:47.425Z",
      "createdAt": "2025-11-09T06:15:47.425Z",
      "id": "tZpzEwpoeg8SrGGa",
      "name": "TEST"
    }
  ]
}